> 软件过程	
	> 软件过程的概念
		> 软件过程是软件生存周期中的一系列相关的过程。过程是活动的集合，活动是任务的集合。
		> 过程定义了活动的时间、人员、工作内容和达到预期目标的途径。
		
	> 过程框架
		> 沟通（需求分析）->策划->建模（设计）->构建（编码）->部署
		
   #> 经典软件过程的特点
		> 瀑布模型（经典生命周期模型）
			> 一种文档驱动、系统、顺序的开发方法
			> 阶段间具有顺序性和依赖性，上一阶段活动完成并经过评审才能开展下一阶段
			> 需求必须是准确定义和相对稳定的，更改需求而修改软件的代价巨大
			> 全过程结束才能看到成品，交付及时性差
			> 错误会被继承，改正错误必须回到之前的阶段，导致瀑布倒流，
			> 阶段间产生大量的文档，极大增大工作量
		> 增量过程模型
			> 增量模型综合了线性过程流和并行过程流的特征。
			> 将整个开发过程分为若干个日程时间交错的可并行的线性序列，每个线性序列生产出可交付增量，是对前一个版本的修改和补充。
			> 第一个增量往往是核心产品，满足了基本的需求。
			> 适用于需求经常发生变化的软件开发。
			> 并行使得人力资源效率最大化
			> 对程序架构要求高
		> 演化过程模型
			> 获取一组需求后先产生出一个原型，然后对原型进行修改和扩展，直到得到满意的产品。
			> 特别适用于对软件需求缺乏准确认识的情况
			> 两种常用的演化过程模型
				> 原型开发
					> 定义软件的整体目标，确定已知的需求，然后以快速设计的方式产生一个原型。
					> 根据用户的反馈，采用迭代的方式在原型上不断调整。
					> 一般是为了需求调研而编写的演示程序，这是与螺旋模型的区别
				> 螺旋模型
					> 风险驱动
					> 结合了原型的迭代性质和瀑布模型的可控性和系统性特点，还增加了风险分析。
					> 每次迭代都包含制定计划、风险分析、工程实施及客户评估4个阶段，每次迭代产生一个新的版本
					> 采用循环的方式逐步加深系统定义和实现的深度，同时降低风险。
					> 螺旋模型能应用在软件的整个生命周期。
		> 统一过程模型（Rational Unified Process）
			> 用例驱动，以架构为核心，迭代并增量。
			> 由四个阶段组成
				> 初始阶段 提出大致的系统架构
				> 细化阶段 根据主要的用例描述设计出详细的系统构架
				> 构造阶段 构造出最终产品
				> 移交阶段 进行系统部署，系统测试，最终移交给用户
			> 四个阶段可能是阶段性地并发进行的。
			
   #> CMM&CMMI
		> CMM:Capability Maturity Model，能力成熟度模型，表明了一个软件组织的过程能力水平
			> 目的：提供一种评价软件承接方能力的方法，帮助软件组织改进其软件过程
			> 两个主要应用：软件过程评估和软件能力评价。
				分5个等级：
				1、初始级：软件过程的特征是无序的，有时甚至是混乱的
				2、可重复级：建立了基本的项目管理过程(过程模型),来跟踪成本、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功
				3、已定义级：已经定义了完整的软件过程（过程模型），软件过程已经文档化和标准化。所有的项目组都使用文档化的、经过批准的过程来开发和维护软件
				4、已（量化）管理级：对软件过程和产品都有定量的理解和控制
				5、优化级：通过过程的量化反馈和先进的新思想、新技术促使过程不断改进			
		> CMMI Capability Maturity Model Integration 能力成熟度模型集成 适用于集成化产品开发的能力成熟度模型
			> 概念：是若干过程模型的综合&改进，是支持多个工程学科&领域的系统一致的过程改进框架，能适应现代工程的特点和需要，提高过程的质量和工作效率
			> 过程域是一类相关实践活动的集合，是建立过程能力的主要元素
			> 两种表示法：
				1.阶段式模型，类同于CMM，关注组织的成熟度，分为5个成熟度等级；
				2.连续式模型，关注每个过程域的能力，分为6个能力等级。一个组织对不同的过程域可以达到不同的过程域能力等级（capability level）
			> 阶段式模型5个成熟度等级：
				1.初始级-过程不可预测且缺乏控制；
				2.已管理级-过程为项目服务；
				3.已定义级-过程为组织服务；
				4.量化管理级-过程已度量且控制；
				5.优化级-集中于过程改进
			> 连续式模型6个能力等级（能力等级可以独立地应用于任何单独的过程域）：
				0.未完成的-过程域未执行或未达到CL1中定义的所有目标
				1.已执行级-将可标识的输入工作产品转换成可标识的输出工作产品，以实现特定目标
				2.已管理级-目标集中于已管理的过程的制度化
				3.已定义级-目标集中于已定义的过程的制度化
				4.量化管理级-目标集中于可定量管理的过程的制度化
				5.优化级-使用量化手段改变和优化过程域
	> 过程评估
		> 软件过程评估所关注的是软件组织自身内部软件过程的改进问题，目的在于发现缺陷，提出改进的方向。
		
	> 敏捷宣言与敏捷过程的特点
		> 敏捷宣言是一个指导迭代的以人为中心的软件开发方法。
		> 敏捷宣言4个价值观
			> 个体和互动 高于 过程和工具（以人为本）
			> 可工作的软件 高于 详尽的文档 （目标导向）
			> 客户合作 高于 合同谈判 （客户为先）
			> 响应变化 高于 遵循计划（拥抱变化）
			
			> 最后，还应记住敏捷宣言中的最后一句话：“ 尽管右项有其价值，我们更重视左项的价值”—敏捷宣言并未否定或贬损“ 右项” 的价值
			> 在敏捷开发的价值观中承认“ 流程和工具”、“ 详尽的文档”、“ 合同谈判” 以及“ 遵循计划” 的重要性，只是两相比较，“ 更重视左项的价值”。
		> 敏捷过程的特点（实际上就是对应敏捷宣言4个方面总结出来的，敏捷宣言背下来了这个就可以自己总结出来）
			1.更注重人的因素（1、3）
			2.测试驱动而非文档驱动（2）
			3.相较于传统开发有着更强的适应性而非预设性（4）

> 软件需求
	> 软件需求的概念
		> 软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望
		> 功能需求（能做什么）
		> 性能需求（性能指标）
		> 用户或人的因素（考虑用户的类型）
		> 环境需求（软件应用的环境，如操作系统、数据库；硬件应用的环境）
		> 界面需求（不同系统输入输出间对数据格式、存储介质的规定）
		> 文档需求（需要哪些文档，阅读对象是谁）
		> 数据需求（输入输出数据的格式、发送频率、精度、流量、保持时间）
		> 资源使用需求（运行时：数据、相关软件、内存空间等；开发时：人力、支撑软件、开发设备等）
		> 安全保密需求
		> 可靠性需求
		> 软件成本消耗与开发进度需求
		> 其他非功能性需求
	
	> 需求工程的基本过程：六个阶段并非线性，而是交叉迭代的
		> 需求获取：识别需求来源，收集并获取初始的系统需求信息，建立对于待解决问题的基本认识，初步明确待开发系统的范围
		> 需求分析：对收集的需求信息进行分类，分析每个需求间的关系，通过谈判过程来调解不同用户需求间的冲突
			> 需求分析原则
				> 必须能够表示和理解问题的信息域
				> 必须能够定义软件将完成的功能
				> 必须能够表示软件的行为
				> 必须划分描述数据、功能和行为的模型，从而可以分层次地揭示细节
				> 分析过程应该从要素信息移向细节信息
		> 系统建模：通过合适的工具和符号系统地描述需求。
			> 面向数据流方法
			> 面向数据结构方法
			> 面向对象方法
		> 需求规约：需求规约是分析的最终产物，通过完整的描述给出对目标软件的各种需求，是用户和开发者之间的一个协议。
		> 需求验证：需求开发阶段工作的复查手段，对功能的正确性、完整性和清晰性以及其他需求给与评价。
		> 需求管理：对需求工程所有相关活动的规划和控制，是一个使用户与项目团队对不断变更的系统需求达成并保持一致的过程。
		
	> 怎么获取软件需求
		> 建立顺畅的通信途径（建立良好的沟通方式）
		> 访谈与调查（获取初期）
		> 观察用户操作流程
		> 组成联合小组(打破需方和供方的界限）
		> 在会议中使用用况/用例（原型法）（一组待建造的系统的使用场景）
		
> 软件设计与构造
	> 软件体系结构及体系结构风格的概念
		> 体系结构包括一组构件，构件外部可见属性和构件之间的关系
		> 体系结构风格描述了特定系统组织方式的惯用模式（构件，连接件及它们之间的约束）。
			> 以数据为中心的体系结构：数据存储（文件或数据库）为体系结构的中心，可集成性强，因为客户构件是独立运作的
			> 数据流体系结构：适用于输入数据被一系列的计算或者处理部件变换成输出数据（面向过程）
			> 调用和返回体系结构：该体系结构易于修改和扩展，分为主程序/子程序风格和远程过程调用风格两种子结构（基于对象）
			> 面向对象体系结构：系统部件封装数据和操作数据的方法，部件间通过消息传递来交互
			> 层次风格体系结构：定义不同的层次，每层都完成了相对外层更接近机器指令的操作（shell和kernel）
	
	> 设计模式的概念
		> 设计模式是一种可复用的解决问题的方案。
		> 体系结构风格与设计模式的区别（方案域和问题域、顶层和底层的区别）
			> 模式描述了软件如何在基础设施层次上处理某些功能性方面的问题
			> 模式设计的范围更小，更关住体系结构的某一方面。
			> 模式倾向于在体系结构环境中处理特定的行为问题
	
   #> 模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）
		> 抽象：抽象要求人们将注意力集中在某一层次上考虑问题，忽略低层次的细节，是从特殊到一般的过程。
		> 求精：一种自顶向下的策略，把问题的求解分解成若干层次和阶段，每一步都比上一步更精细化、更接近问题的解法。
			> 二者是一对互补的概念，抽象使得设计者能够描述过程和数据而隐藏底层细节，求精有助于设计者在设计过程中揭示底层细节。
		> 分离：关注点分离,通过“分而治之”的策略把一个复杂的问题分解为多个易解决的问题。
		> 模块化：将软件划分为若干个独立命名的、可处理的构件。
		    > 模块化使软件更容易设计、理解、调试和测试。
		    > 模块使用者只需要了解功能和接口，不必了解模块内部的实现细节。
		> 封装(信息隐藏)：将抽象得到的数据和方法相结合，形成一个有机的整体，隐藏对象的属性和实现细节，仅对外提供接口。
		> 功能独立：是分离、模块化、抽象和封装的直接产物。设计模块时其功能应当“单一”（单一职责原则），与其他模块的接口应简单（接口分离原则）。
	
	> 软件重构
		> 重构是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为。
	
	> 接口的概念
		> 模块间发生交互的方法
		
   #> 面向对象设计原则
        > SOLID五原则
            > 单一职责原则（Single Responsibility Principle）
				> 一个类尽量只负责一个任务
            > 开放闭合原则（Open Close Principle）针对于抽象/接口编程
                > 对扩展开放：有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况
				> 对修改关闭：类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改
            > 里氏替换原则（Liskov Substitution Principle）
                > 派生类一定要适应基类（任何地方派生类都可以替代基类，如基类指针指向派生类对象（静态联编，只能访问基类成员），实现向上转型）
            > 接口分离原则（Interface Segregation Principle）
                > 类间的依赖关系应该建立在最小的接口上
				> 多个客户专用接口比一个通用接口要好
            > 依赖倒置原则（Dependence Inversion Principle）
                > 高层模块不依赖于低层模块，二者都应依赖于抽象接口
				> 抽象不应该依赖于具体，具体应该依赖于抽象
		
   #> 内聚与耦合的概念
		> 耦合性：模块间的相互依赖程度
		> 耦合的种类（耦合度由低到高）
			> 非直接耦合：两个模块无直接关系
			> 数据耦合：两个模块间仅通过参数表传递简单数据（依赖关系）
			> 标记耦合：当把整个数据结构作为参数传递而被调用模块只需要使用其中一部分数据元素（传递了多余的信息）
			> 控制耦合：模块A向模块B传递的信息控制了模块B的内部逻辑，那么A和B之间则称为控制耦合。
			> 外部耦合：模块间通过软件之外的环境联结（如I/O设备）
			> 公共耦合：如果多个模块都和同一个公共数据域（全局变量，共享内存等）有关，则称为公共耦合。公共耦合是一种不良的耦合关系，它给模块的维护和修改带来困难。
			> 内容耦合：一个模块可以直接访问另一个模块的内部数据（友元类破坏封装性）	
		> 内聚性：模块内各元素结合的紧密程度(内聚性由高到低）
				  内聚性意味着构件只封装那些相互关联密切，以及与构件自身有密切关系的属性和操作
			> 功能内聚：模块内的各组成部分都是为完成一项具体功能而协同工作，紧密联系，不可分割。
			> 顺序内聚：一个模块完成多个功能，这些功能必须顺序执行，因为前一个功能的输出是后一个功能的输入。
			> 通信内聚：模块内所有处理元素都集中在某个数据结构（的一块区域）中（传参只穿这个数据结构即可）
			> 过程内聚：模块内多个任务必须按指定的过程执行。
			> 时间内聚（暂时内聚）：模块中的所有任务必须在同一时间段内执行（如初始化和终止）
			> 逻辑内聚：由完成一组逻辑相关任务的功能构成的模块，由控制型参数决定该模块执行哪一种功能
			> 偶然内聚（机械内聚）：一个模块的内部各组成部分的处理动作彼此没有任何联系，则称为偶然内聚
		> 低耦合高内聚独立性更强
		> 提高独立性先解决耦合问题再提高内聚
		
> 软件测试
	> 软件测试及测试用例的概念
		> 软件测试的目的：
			> 以最小代价（这是一个工程问题）系统地发现各种不同类型的错误
			> 检验是否满足需求
			> 建立信心
		> 测试用例：为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求
		> 测试用例的优劣
			> 书写格式正确、描述清晰（其他人能看懂，能执行）
			> 对测试点覆盖完全
			> 能找到尚未发现的错误
			> 一个用例能判断尽量多的条件
			
   #> 调试的概念、调试与测试的关系
		> 测试的目的是发现错误，当测试发现错误后需要进行调试
		> 调试的目的是确定错误的原因和准确位置，并加以纠正
		> 调试方法
			> 蛮干法：设置断点，打印变量等方法，最常用但是低效
			> 回溯法：人工沿着控制流往回跟踪以发现错误
			> 原因排除法：归纳/演绎
			> 自动调试
	
   #> 测试策略(注意对应的V模型（开发和测试对应）p267）
		> 单元测试（对应编码）
			> 对象：软件设计的最小单元——模块
			> 目的：揭露编码阶段产生的错误；根据设计描述，对重要的控制路径进行测试，以发现模块内部的错误
			> 特点：可并行测试；常用白盒测试
		> 集成测试（对应设计）
			> 对象：集成的软件系统
			> 目的：揭露设计阶段产生的错误；利用已通过单元测试的模块建立设计中描述的程序结构
			> 增量集成测试
				> 增量集成程序以小增量的方式逐步进行构建和测试，这样错误易于分离和纠正，更易于对接口进行彻底测试，而且可以运用系统化的测试方法。
				> 自顶向下集成测试（类似于最小生成树）
					> 从主控模块（主程序）开始
					> 用广度/深度优先，将直接或间接从属于主控模块的模块逐个集成到整个结构中，并进行测试
					> 不需要驱动程序（上层模块作为驱动）
				> 自底向上集成测试
					> 从程序结构的最底层原子模块开始，将上层模块逐步集成到整个结构中，并进行测试
					> 不需要桩模块（下层模块作为桩模块）
		> 回归测试：每加入一个新模块作为集成测试的一部分时，回归测试重新执行已经测试过的某些子集，以确保变更没有传播副作用。
		> 确认测试（对应需求分析）
			> 对象：集成测试后的软件
			> 目的：以软件需求规约为依据，揭露不符合需求规约的错误
			> 特点：通常采用黑盒测试
		> 系统测试（对应系统工程）
			> 对象：集成于计算机系统中的软件，将硬件、软件、操作人员看作一个整体
			> 目的：将它集成到基于计算机的系统中进行测试，以揭露不符合系统工程中对软件要求的错误 
			> 恢复测试 通过各种方式强制的让系统发生故障，并验证其能适当恢复
			> 安全测试 验证系统内部的保护机制，以防止非法侵入
			> 压力测试 在一种非正常数量、频率或容量的方式下执行系统，以检查系统对非正常情况的承受程度
			> 性能测试 用来测试软件在集成系统中的运行性能
			> 部署测试 在多种平台及操作系统环境中运行软件
		
		
   #> 测试覆盖度的概念
		> 测试覆盖度指测试系统覆盖被测试系统的程度
		> 测试覆盖率是测试覆盖度评估中一种量化的表示方法，一般通过被测试的软件产品需求、功能点、测试用例数或程序代码行等来进行计算。
		> 软件测试覆盖率常用的计算公式：
			> 功能覆盖率= 执行的测试功能点数/总的测试功能点数 （功能点）
			> 需求覆盖率= 被验证到的需求数量/总的需求数量 （需求）
			> 覆盖率= 执行过的测试用例数/ 应执行的测试用例总数 （测试用例）
			> 语句覆盖率= 执行过的语句数量/ 有效的程序代码行数
			> 判定覆盖率= 出现过的判定结果数 / 判定结果总数
				> 判定结果数即判定框的出度个数
			> 条件覆盖率= 出现过的条件操作数值数 / 条件操作数值的总数
				> 条件属于判定语句，即一个判定语句中可能有多个条件，条件覆盖要求每个条件的所有可能结果都至少出现一次
				> 所有条件的可能结果个数为复合判定语句拆分成简单判定语句后总的判定框出度个数
			> 判定条件覆盖率= 出现过的条件操作数值或判定结果的数量/(条件操作数值总数+判定结果总数)
			  满足判定条件一定满足语句、判定、条件
			> 条件组合覆盖= 执行过的条件组合/总的可能的条件组合数 
			> 路径覆盖率= 至少被执行一次的路径数/程序总路径数
			
   #> 白盒测试/黑盒测试
		> 白盒测试
			> 又称结构测试，测试对象内部结构对测试人员可见，测试人员根据程序内部的逻辑结构及有关信息设计测试用例，用以检查逻辑错误
			> 白盒测试对程序模块的所有的执行路径至少测试一次
			> 对所有的逻辑判定，取“真”与取“假” 白盒测试的两种情况都至少测试一次
			> 白盒测试也叫逻辑覆盖法包括：语句覆盖，判定覆盖，条件覆盖
			> 发生在测试过程早期
		   #> 基本路径测试（语句覆盖）：把测试的程序路径数压缩到一定的范围的方法，执行该基本集导出的测试用例保证程序中的每一条语句至少执行一次
				> 根据程序或设计图画出控制流程图
				> 设计图中一组连续的处理框（顺序语句）和一个判定框（分支/循环/判断等，复合条件必须先转换成等价的简单条件）映射成流图中的一个节点
				> 计算圈复杂度
					#> 代码圈复杂度
						> 圈复杂度用来衡量一个模块判定结构的复杂程度
						> 圈复杂度定义了程序基本路径集中的独立路径数，并提供了保证所有语句至少执行一次所需的测试数量下界
							> 流图中由节点和边组成的闭合部分称为一个区域，图的外部部分也作一个区域
							> 独立路径是指任何贯穿程序的、至少引入一个新的处理语句序列或一个新条件的路径
							> 独立路径数=区域数
							> 圈复杂度计算公式
								> 图G，圈复杂度V(G)，边数E，节点数N，判定节点数P
								> V(G)=E-N+2=P+1=区域数=独立路径数
								> 即最多V(G)个测试用例就可以达到对基本路径的覆盖
				> 确定一组独立的程序执行路径（基本路径集，不唯一）
				> 为每一条基本路径设计一个测试用例
			> 通过白盒测试还可以提高鲁棒性
		> 黑盒测试
			> 又称为行为测试或功能测试，测试对象内部结构对测试人员透明，测试人员依据需求规约，检查程序的功能是否符合要求
			> 黑盒测试方法：等价类划分，边界值分析，比较测试，错误猜测和因果图
			> 黑盒测试试图发现以下类型的错误：
				> 不正确或遗漏的功能
				> 接口错误
				> 数据结构或者外部数据库访问错误
				> 行为或性能错误
				> 初始化和终止错误
			> 黑盒测试应用在测试的后期阶段，侧重于信息域
		   #> 等价类划分
				> 等价类划分是一种黑盒测试方法，它将程序的输入划分为若干个数据类，从中生成测试用例。
				> 有效等价类：符合规格说明要求的合理的输入数据集，测试能否正常实现功能
				> 无效等价类：不符合规格说明要求的不合理的或非法的输入数据集，测试鲁棒性、容错性
				> 划分方法（根据不同约束来进行分类，将数轴分段，左无效，有效，右无效）
					> 若输入条件指定一个范围，则可以确定一个有效等价类和两个无效等价类（集合内、集合左、集合右）
					> 若输入条件需要特定的值，则可以确定一个有效等价类和两个无效等价类（等于、大于和小于）
					> 若输入条件指定集合的某个元素，则每个允许的值都确定为一个有效等价类，另外还有一个无效等价类（属于集合的每个元素和不属于集合的元素）
					> 若输入条件为bool值，则可以确定一个有效等价类和一个无效等价类（true or false）
				> 设计规则
					> 新的测试用例尽可能多地覆盖尚未被覆盖的有效等价类，重复直到覆盖所有有效等价类
					> 为每个无效等价类设计一个新的测试用例（因为无效等价类都是测试非正常输入的情况，很可能发现错误）
				
> 画图
	> 用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）
		> 用例图：执行者、用例和他们之间的关系（18、   p145
			> 方框代表系统，椭圆代表用例，线条人代表执行者，直线表示通信路径
			> 执行者：与系统交互者（并不一定是人）
			> 用例：执行者所感受到的一个完整的功能
			> 用例图中涉及的关系有：关联、泛化、包含、扩展。
				> 包含
					> 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤，这些较小的步骤具有相对独立性，可以被多个用况引用
					> 包含用况定义的行为被包含在基本用况所定义的行为中
					> UML: 虚线箭头《include》，指向分解出来的功能用例
				> 扩展
					> 扩展的用况到基本用况的一种关系，指出扩展的用况所定义的行为如何插入到基本用况所定义的行为。扩展用况是对基本用况的增量修改
					> UML：虚线箭头《extend》，指向被扩展的用例(基用例）
					> 扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。
		
		> 活动图
			> 对系统动态方面建模，强调的是从活动到活动的控制流
			> 活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。
			> 在状态机图的符号基础上增加了菱形符号作为判定符号，可以携带两个以上的监护条件，形成分支
			> bar用于将一个控制流分为两个或多个并发运行的分支，或将多个控制流合并到一起形成一个单向的控制流，属于同步控制
			> 与状态机图的区别在于不依靠事件触发，动作状态中的活动完成时迁移就触发，所以箭头上只写监护条件和动作表达式，也可不写
			> 带有对象的活动图中，对象是矩形，作为活动的输入或输出，用虚线箭头连接
			> 活动图也可描述用例，p173
		> 泳道图
			> 在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。
			> 每个泳道最上方写对象名
			> 泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。
			> 泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道
			> 不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。
		> 顺序图
			> 描述对象按时间顺序交换的消息交换过程，体现出系统用例的行为
			> 普通箭头代表简单消息
			> 实心三角箭头代表同步消息
			> 上半部分普通箭头代表异步消息
			> 虚线箭头表示返回消息（可选）
			> 生命线是虚线，生命线上打X代表对象消亡
			> 被激活的对象在生命线上是细长的空心矩形
			> 递归是一个对象给自己发同步消息
			> 分支允许控制流（消息）走向不同对象
			> 从属流允许控制流根据条件改变，但只允许改变为指向同一个对象的生命线分支
	
	> 数据模型建模及其UML表达（类图）（20、18、17）
		> 类与类之间的关系
			> 依赖 
				> 偶然的，并不是固定的
				> 语义上: A use B
				> UML: 虚线箭头
				> 代码:
					> A成员函数参数 A-->B
					> 在类A成员函数内部创建B类对象(返回值)
					> 在类A成员函数内部调用B类的静态方法

			> 关联
				> 固定的
					> 单向的关联关系  UML: 直线箭头
					> 双向的关联关系  UML: 直线
					> 多元关联关系 UML：一个菱形以及由菱形引出的通向各个相关类的直线
				> 语义上： A has B，一个类知道另一个类的变化
				> 彼此并不负责对方的生命周期          
				> 代码:
					> 指针或者引用类型的成员     （Condition ——> MutexLock）
					> A可直接通过指向B成员的指针调用B的方法

			> 聚合
				> 固定的
				> 具有整体与局部的关系（与关联的区别）
				> UML: 空心的菱形箭头, 菱形箭头指向的整体，一般部分类是控制类（动宾结构），整体类是实体类（名词）
				> 语义上： A has B
				> 整体并不负责局部的生命周期（没有了整体，局部依然存在），部分类在整体类外被构造，整体类被析构时，部分类并不会被析构
				> 代码:
					> 指针或者引用类型的成员
					> A可直接通过指向B成员的指针调用B的方法

			> 组合
				> 固定的
				> 具有整体与局部的关系
	  			> UML: 实心的菱形箭头, 菱形箭头指向的整体
				> 语义上： A has B
				> 整体负责局部的生命周期（强包含关系）
				> 组合关系的“部分”，是不能在整体之间进行共享的。
				> 代码:
					> 对象成员
			
			> 泛化
				> UML: 实线+空心的三角箭头
				
			> 实现
				> 是一种类与接口的关系，表示类是接口所有特征和行为的实现。
				> UML：虚线空心三角箭头，从实现指向接口（接口类是普通类的名字左侧有一个 o- 符号）
				> 代码
					> 对抽象类纯虚函数的实现（纯虚函数只有声明，没有实现，其实现要交给派生类完成）
		> 可见性
			> + Public 对任何人可见
			> # Protected 对子类也可见
			> - Private	只对自己可见
			> ~ Package（包的）对在同一个包中的类可见
	> 行为模型建模及其UML表达（状态机图）
		> 状态机图（20、19）
			> 描述了对象的动态行为，是一种对象生存周期的模型
			> 可以有一个开始多个结束
			> 状态迁移格式：事件(参数)[监护条件]/动作
			> 状态：表示该对象执行了之前活动后的结果
				> 状态迁移用连接两个状态之间的箭头表示，在箭头上标上引起这一迁移的事件
				> 状态迁移也可加上条件，在箭头上标上[监护条件]，接收到状态转移事件同时满足监护条件才会发生状态转移
			> 事件：触发状态迁移
				> 调用事件：直接写动作
				> 变化事件：when(逻辑表达式)/动作，即满足逻辑表达式时发生事件
				> 时间事件
					> after(时间表达式)/动作，经过一定时间后发生
					> at(时间表达式)/动作，到达某时刻发生
			> 动作：事件要求对象做某件事情，这个事情被称为动作。动作改变了对象属性的值，导致对象的状态发生变化。
			> 事件与动作既可用于转移中，也可用于单独的状态中。
			> 状态内三种动作
				> entry（入口动作）:进入状态时最先执行的特定动作，不带条件与参数。格式为：entry/动作
				> exit（出口动作）:退出该状态时最后执行的特定动作，不带条件与参数。格式为：exit/动作
				> do（内部活动）:用来指定处于某种状态时发生的动作。在入口事件之后，出口事件之前执行的特定动作。
	> 软件体系结构的UML建模（数据流图、包图、类图、构件图、顺序图、部署图）
		> 数据流图（19、18）
			> 看书 p69
			> 单向箭头表示数据流入或流出
			> 双向箭头可指向文件，表示对文件的修改，不用写数据流名称
			> 矩形方框代表数据源点或汇点
			> 圆圈代表加工
			> 两道平行横杠代表文件，两横间写文件名
			> 顶层图只有一个加工，即软件系统，没有编号
			> 0层图加工编号1、2、.....
			> 1层图加工编号1.1、1.2、.....
			> 父图中出现的文件应画在子图中
		> 包图
			> 对文件进行分类管理
			> 避免了命名冲突（一个包就是一个命名空间）
			> public(+):可在其他任何包中使用
			> private(-):只能在该包中使用
			> protected(#):可以在该包和该包的子包中使用
			> 包的导入  A--import-->B
				> 导入后包A中的元素可以直接访问包B中的元素，而不必在每次使用时用完整的路径名
				
		> 构件图
			